# 享元模式（Flyweight Pattern）

> Use sharing to support large numbers of fine-grained objects efficiently.

> 使用共享对象可有效地支持大量细粒度的对象。

![flyweight-pattern](../res/images/flyweight-pattern.svg)

* Flyweight抽象享元角色

    简单的说，它是一个产品抽象类，同时定义了对象的外部状态和内部状态的接口或实现。

* ConcreteFlyweight具体享元角色

    具体的一个产品类，实现抽象角色定义的业务。该角色中需要注意的是内部状态处理应该与环境无关，不应该出现一个操作改变内部状态，同时修改了外部状态。

* UnsharedConcreteFlyweight不可共享的享元角色

    不存在外部状态或者安全要求（如线程安全）不能够使用共享技术的对象，该对象一般不会出现在享元工厂中。

* FFlyweightFactory享元工厂

    职责非常简单，就是构造一个容器，同时提供从池中获得对象的方法。

## 享元模式的优点

享元模式能大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能。

## 享元模式的缺点

需要分离外部状态和内部状态，提高了系统的复杂性，而且外部状态具有固化型，不能随内部状态改变而改变，否则导致系统的逻辑混乱。

## 享元模式的使用场景

* 系统中存在大量的相似对象。

* 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。

* 需要缓冲池的场景。
