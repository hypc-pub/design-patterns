{"./":{"url":"./","title":"简介","keywords":"","body":"Design Patterns 设计原则 单一职责原则 里氏替换原则 依赖倒置原则 接口隔离原则 迪米特法则 开闭原则 设计模式 单例模式 工厂方法模式 抽象工厂模式 模板方法模式 建造者模式 代理模式 原型模式 中介者模式 命令模式 责任链模式 装饰模式 策略模式 适配器模式 迭代器模式 组合模式 观察者模式 门面模式 备忘录模式 访问者模式 状态模式 解释器模式 享元模式 桥梁模式 "},"principles/srp.html":{"url":"principles/srp.html","title":"单一职责原则","keywords":"","body":"单一职责原则 单一职责原则（SRP：Single Responsibility Principle）：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。 遵循单一职责原的优点： 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； 提高类的可读性，提高系统的可维护性； 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。 需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。 "},"principles/lsp.html":{"url":"principles/lsp.html","title":"里氏替换原则","keywords":"","body":"里氏替换原则 里氏替换原则（LSP：Liskov Substitution Principle）：所有引用基类的地方必须能透明地使用其子类的对象。 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 "},"principles/dip.html":{"url":"principles/dip.html","title":"依赖倒置原则","keywords":"","body":"依赖倒置原则 依赖倒置原则（DIP：Dependence Inversion Principle）：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 在实际编程中，我们一般需要做到如下3点： 低层模块尽量都要有抽象类或接口，或者两者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。 依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。 "},"principles/isp.html":{"url":"principles/isp.html","title":"接口隔离原则","keywords":"","body":"接口隔离原则 接口隔离原则（ISP：Interface Segregation Principle）：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 "},"principles/lod.html":{"url":"principles/lod.html","title":"迪米特法则","keywords":"","body":"迪米特法则 迪米特法则:（LoD：Law of Demeter）：一个对象应该对其他对象保持最少的了解。 迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖， 因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信， 但是要通信，必然会通过一个中介来发生联系。 过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。 所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。 "},"principles/ocp.html":{"url":"principles/ocp.html","title":"开闭原则","keywords":"","body":"开闭原则 开闭原则（OCP：Open Closed Principle）：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。 开闭原则可能是设计模式六项原则中定义最模糊的一个了， 它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。 以前，如果有人告诉我『你进行设计的时候一定要遵守开闭原则』，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。 "},"patterns/singleton-pattern.html":{"url":"patterns/singleton-pattern.html","title":"单例模式","keywords":"","body":"单例模式（Singleton Pattern） Ensure a class has only one instance, and provide a global point of access to it. 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 单例模式的优点 由于单例模式在内存中只有一个实例，减少了内存开支。 由于单例模式只生成一个实例，所以减少了系统的性能开销。 单例模式可以避免对资源的多重占用。 单例模式可以在系统设置全局的访问点，优化和共享资源访问。 单例模式的缺点 单例模式一般没有接口，扩展很困难。 单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。 单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境。 单例模式注意事项 在高并发情况下，注意单例模式的线程同步问题。 考虑对象的复制情况。 单例模式的扩展 如果一个类可以产生多个对象，对象的数量不受限制，直接使用new关键字就可以了，如果只要有一个对象，使用单例模式就可以了，但是如果要求一个类只能产生两三个对象，这时候可以使用多例模式。 需要产生固定数量对象的模式叫做有上限的多例模式，它是单例模式的一种扩展，采用有上限的多例模式，我们可以在设计时决定在内存中有多少个实例，方便系统进行扩展，修正单例可能存在的性能问题，提供系统的响应速度。 "},"patterns/factory-method-pattern.html":{"url":"patterns/factory-method-pattern.html","title":"工厂方法模式","keywords":"","body":"工厂方法模式（Factory Method Pattern） Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses. 顶一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 工厂方法模式的优点 良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。 工厂方法模式的扩展性非常优秀。在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，就可以完成『拥抱变化』。 屏蔽产品类。这一特点非常有用，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就需要发生变化。 工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不用关心。 工厂方法模式的扩展 缩小为简单工厂模式（Simple Factory Pattern） 简单工厂模式也叫做静态工厂模式。在实际项目中，采用该方法的案例还是比较多的， 其缺点是工厂类的扩展比较困难，不符合开闭原则，但它仍然是一个非常实用的设计模式。 升级为多个工厂类 每一个产品类都对应了一个创建类，好处就是创建类的职责清晰，而且结构简单，但是给可扩展性和可维护性带来了一定的影响。 由于要扩展一个产品类，就需要建立一个相应的工厂类，这样就增加了扩展的难度。 因为工厂类和产品类的数量相同，维护时需要考虑两个对象之间的关系。 替代单例模式 延迟初始化 延迟初始化（Lazy initialization）：一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。 延迟初始化是工厂模式的一个扩展应用。 "},"patterns/abstract_factory_pattern.html":{"url":"patterns/abstract_factory_pattern.html","title":"抽象工厂模式","keywords":"","body":"抽象工厂模式（Abstract Factory Pattern） Provide an interface for creating families of related or dependent objects without specifying their concrete classes. 为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类。 抽象工厂模式的优点 封装性。每个产品的实现类不是高层模块要关心的，它要关心的是接口，是抽象，它不关心对象是如何创建出来。它只需要关心工厂，只要知道工厂是谁，就能创建出一个需要的对象。 产品族内的约束为非公开状态。 抽象工厂模式的缺点 抽象工厂模式的最大缺点就是产品族扩展非常困难。增加一个产品A，抽象类AbstractCreator要增加一个方法createProductA()，然后两个实现类都要修改，这严重违反了开闭原则。 抽象工厂模式的使用场景 抽象工厂模式的使用场景定义非常简单：一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式。 抽象工厂模式的注意事项 在抽象工厂模式的缺点中，我们提到抽象工厂模式的产品族扩展比较困难，但是一定要清楚，是产品族扩展困难，而不是产品等级。 在该模式下，产品等级是非常容易扩展的，增加一个产品等级，只要增加一个工厂类负责新增加出来的产品生产任务即可。 也即是说，横向扩展容易，纵向扩展困难。 "},"patterns/template_method_pattern.html":{"url":"patterns/template_method_pattern.html","title":"模板方法模式","keywords":"","body":"模板方法模式（Template Method Pattern） Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure. 定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 基本方法 基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用。 模板方法 可以有一个或几个，一般是一个具体方法，也叫做一个框架，实现对基本方法的调度，完成固定的逻辑。 为了防止恶意操作，一般模板方法都加上final关键字，不允许被覆写。 模板方法模式的优点 封装不变部分，扩展可变部分 提取公共部分代码，便于维护 行为由父类控制，子类实现 模板方法模式的缺点 按照一般设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度。 模板方法模式的使用场景 多个子类有公有的方法，并且逻辑基本相同。 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。 "},"patterns/builder-pattern.html":{"url":"patterns/builder-pattern.html","title":"建造者模式","keywords":"","body":"建造者模式（Builder Pattern） Separate the construction of a complex object from its representation so that the same construction process can create different representation. 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式的优点 封装性：使用建造者模式可以使客户端不必知道产品内部组成的细节。 建造者独立，容易扩展。 便于控制细节风险，由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的莫乱产生任何影响。 建造者模式的使用场景 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以采用该模式。 产品类非常复杂，或者产品类中的电泳顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到，也可以采用建造者模式封装该对象的创建过程。该中场景智能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反了设计的最初目标。 建造者模式的注意事项 建造者模式关注的是零件类型和装配工艺（顺序），这是它与工厂方法模式最大不同的地方，虽然同为创建类模式，但是注重点不同。 "},"patterns/proxy-pattern.html":{"url":"patterns/proxy-pattern.html","title":"代理模式","keywords":"","body":"代理模式（Proxy Pattern） Provide a surrogate or placeholder for another object to control access to it. 为其他对象提供一种代理以控制对这个对象的访问。 代理模式的优点 职责清晰 高扩展性 智能化 代理模式的扩展 普通代理 普通代理，它的要求就是客户端只能访问代理角色，而不能访问真实角色。 强制代理 必须通过真实角色查到代理角色，否则你不能访问。 代理是有个性的 一个类可以实现多个接口，完成不同任务的整合。 虚拟代理 在需要的时候才初始化主体对象，可以避免被代理对象较多引起的初始化缓慢的问题。其缺点是需要在每个方法中判断主体对象是否被创建。 动态代理 "},"patterns/prototype-pattern.html":{"url":"patterns/prototype-pattern.html","title":"原型模式","keywords":"","body":"原型模式（Prototype Pattern） Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype. 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 原型模式的优点 性能优良 原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。 逃避构造函数的约束 这即是优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点是减少了约束，缺点也是减少了约束。 原型模式的使用场景 资源优化场景 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源的。 性能和安全要求的场景 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 一个对象多个修改者的场景 一个对象需要提供给其他对象访问，而且每个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 原型模式的注意事项 构造函数不会被执行 浅拷贝和深拷贝 clone和final "},"patterns/mediator-pattern.html":{"url":"patterns/mediator-pattern.html","title":"中介者模式","keywords":"","body":"中介者模式（Mediator Pattern） Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each explicitly, and it lets you vary their interaction independently. 用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 中介者模式的优点 中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同时降低了类间的耦合。 中介者模式的缺点 中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。 中介者模式使用场景 N个对象之间产生了相互的依赖关系（N>2）。 对个对象有依赖关系，但是依赖的行为尚不确定或者有发生改变的可能，在这种情况下建议采用中介者模式，降低变更引起的风险扩散。 产品开发。把中介者模式应用到产品中，可以提升产品的性能和扩展性，但是对于项目开发就未必，因为项目是以交互投产为目标，而产品则是以稳定、高效、扩展为宗旨。 "},"patterns/command-pattern.html":{"url":"patterns/command-pattern.html","title":"命令模式","keywords":"","body":"命令模式（Command Pattern） Encapsulate a request as an object, thereby letting you parameterize clients with diffrent requests, queue or log requests, and support undoable operations. 将一个对象封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。 命令模式的优点 类间解耦 调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command抽象类的execute方法就可以，不需要了解到底是哪个接收者执行。 可扩展性 Command的子类可以非常容易的扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。 命令模式结合其他模式 命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少Command子类的膨胀问题。 命令模式的缺点 如果有N个命令，那么Command子类就有N个，这个类将膨胀得非常大。 "},"patterns/chain-of-responsibility-pattern.html":{"url":"patterns/chain-of-responsibility-pattern.html","title":"责任链模式","keywords":"","body":"责任链模式（Chain of Responsibility Pattern） Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it. 使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。 责任链模式的优点 责任链模式非常显著的优点是将请求和处理分开。请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌，两者解耦，提高系统的灵活性。 责任链模式的缺点 责任链模式有两个显著的缺点：一是性能问题，每个请求都是从链头便利到链尾，特别是链比较长的时候，性能是一个非常大的问题。二是调试不很方便，特别是链条比较长，环节比较多的时候，由于采用了类似递归的方式，调试的时候逻辑可能比较复杂。 "},"patterns/decorator-pattern.html":{"url":"patterns/decorator-pattern.html","title":"装饰模式","keywords":"","body":"装饰模式（Decorator Pattern） Attach additional responsibilities to an object dynamically keeping the same interface. Decorators provide a flexible alternative to subclassing for extending functionality. 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更灵活。 装饰模式的优点 装饰类和被装饰类可以独立发展，而且不会相互耦合。 装饰模式是继承关系的一个替代方案。 装饰模式可以动态地扩展一个实现类的功能。 装饰模式的缺点 多层装饰是比较复杂的。 装饰模式的使用场景 需要扩展一个类的功能，或给一个类增加附加功能。 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。 需要为一批的兄弟类进行改装或加装功能。 "},"patterns/strategy-pattern.html":{"url":"patterns/strategy-pattern.html","title":"策略模式","keywords":"","body":"策略模式（Strategy Pattern） Define a family of algorithms, encapsulate each one, and make them interchangeable. 定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。 策略模式的优点 算法可以自由切换 避免使用多重条件判断 扩展性良好 策略模式的缺点 策略类数量增多 所有策略类都需要对外暴露 策略模式的使用场景 多个类只有在算法或行为上稍有不同的场景 算法需要自由切换的场景 需要屏蔽算法规则的场景 策略模式的注意事项 如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题，否则日后的系统维护就会成为一个烫手山芋，谁都不想接。 "},"patterns/adapter-pattern.html":{"url":"patterns/adapter-pattern.html","title":"适配器模式","keywords":"","body":"适配器模式 Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces. 将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作。 Target目标角色 该角色定义把其他类转换为何种接口，也就是我们的期望接口。 Adaptee源角色 你想把谁转换成目标角色，这个「谁」就是源角色，它是已经存在的、运行良好的类或对象，经过适配器角色的包装，它会成为一个崭新、靓丽的角色。 Adapter适配器角色 适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，它的职责非常简单：把源角色转换为目标角色，怎么转换？通过继承或是类关联的方式。 适配器模式的优点 适配器模式可以让两个没有任何关系的类一起运行 增加了类的透明性 提高了类的复用性 灵活性非常好 适配器模式的使用场景 你有动机修改一个已经投产的接口时，适配器模式可能是最适合的模式。 适配器模式的注意事项 适配器模式最好在详细设计阶段不要考虑它，它不是为了解决还处在开发阶段的问题，而是解决正在服役的项目的问题，没有一个系统分析师会在做详细设计的时候考虑使用适配器模式，这个模式使用的主要场景是扩展应用。 "},"patterns/iterator-pattern.html":{"url":"patterns/iterator-pattern.html","title":"迭代器模式","keywords":"","body":"迭代器模式（Iterator Pattern） Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation. 它提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。 Iterator抽象迭代器 抽象迭代器负责定义访问和遍历元素的接口，而且基本上是有固定3个方法：first()获得第一个元素，next()访问下一个元素，isDone()或hasNext()是否已经访问到底部。 ConcreteIterator具体迭代器 具体迭代器角色要实现迭代器接口，完成容器元素的遍历。 Aggregate抽象容器 容器角色负责提供创建具体迭代器角色的接口，必然提供一个类似creteIterator()这样的方法。 ConcreteAggregate具体容器 具体容器实现容器接口定义的方法，创建出容纳迭代器的对象。 "},"patterns/composite-pattern.html":{"url":"patterns/composite-pattern.html","title":"组合模式","keywords":"","body":"组合模式（Composite Pattern） Compose objects into tree structures to represent part-whole hierachies. Composite lets clients treat individual objects and compositions of objects uniformly. 讲对象组合成树形结构以表示「部分-整体」的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 Component抽象构件角色 定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。 Leaf叶子构件 叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。 Composite树枝构件 树枝构件，它的作用是组合树枝节点和叶子结点形成一个树形结构。 组合模式的优点 高层模块调用简单 节点自由添加 组合模式的缺点 组合模式有一个非常明显的缺点：在使用树枝或树叶时，直接使用实现类，这在面向接口编程是不恰当的，与依赖倒置原则冲突。 组合模式的使用场景 维护和展示「部分-整体」关系的场景，如树形菜单、文件和文件夹管理。 从一个整体中能够独立出部分模块或功能的场景。 "},"patterns/observer-pattern.html":{"url":"patterns/observer-pattern.html","title":"观察者模式","keywords":"","body":"观察者模式（Observer Pattern） Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. 定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都回得到通知并被自动更新。 Subject被观察者 定义观察者必须实现的职责，它必须能够动态地增加、取消观察者。它一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者。 Observer观察者 观察者接收到消息后，即进行update操作，对接收到的信息进行处理。 ConcreteSubject具体的被观察者 定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。 ConcreteObserver具体的观察者 每个观察者在接收到的消息后的处理反应是不同的，各个观察者有自己的处理逻辑。 观察者模式的优点 观察者和被观察者之间是抽象耦合 如此设计，则不管是增加观察者还是被观察者都非常容易扩展。 建议一套触发机制 观察者模式的缺点 观察者模式需要考虑一下开发效率和运行效率问题，一个被观察者，多个观察者，开发和调试就会比较复杂。而一般情况下，消息的通知默认是顺序执行，一个观察者卡壳，会影响整体的执行效率。在这种情况下，可考虑异步。 观察者模式的使用场景 关联行为场景 事件多级触发场景 跨系统的消息交换场景，如消息队列的处理机制 "},"patterns/facade-pattern.html":{"url":"patterns/facade-pattern.html","title":"门面模式","keywords":"","body":"门面模式（Facade Pattern） Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use. 要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。 Facade门面角色 客户端可以调用这个角色的方法。此角色知晓子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发来的请求委派到响应的子系统去，也就是说该角色没有实际的业务逻辑，知识一个委托类。 Subsystem子系统角色 可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统并不知道门面的存在。对于子系统而言，门面仅仅是另外一个客户端而已。 门面模式的优点 减少系统的相互依赖 提高了灵活性 提高安全性 门面模式的缺点 门面模式的缺点就是不符合开闭原则，对修改关闭，对扩展开放。 门面模式的使用场景 为一个复杂的模块或子系统提供一个供外界访问的接口 子系统相对独立--外界对子系统的访问只要黑箱操作即可 预防低水平人员带来的风险扩散 "},"patterns/memento-pattern.html":{"url":"patterns/memento-pattern.html","title":"备忘录模式","keywords":"","body":"备忘录模式（Memento Pattern） Without violating encapsulation, capture and externalize an object's internal state so that the object can be restored to this state later. 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。 Originator发起人角色 记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。 Memento备忘录角色 负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。 Caretaker备忘录管理员角色 对备忘录进行管理、保存和提供备忘录。 备忘录模式的使用场景 需要保存和恢复数据的相关状态场景 提供一个可回滚的操作 需要监控的副本场景中 数据库连接的事务管理 "},"patterns/visitor-pattern.html":{"url":"patterns/visitor-pattern.html","title":"访问者模式","keywords":"","body":"访问者模式（Visitor Pattern） Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates. 封装一些作用于某些数据结构中各元素的操作，它可以在不修改数据结构的前提下定义作用于这些元素的新的操作。 Visitor抽象访问者 抽象类或接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定义哪些对象是可以被访问的。 ConcreteVistor具体访问者 它影响访问者访问到一个类后该怎么干，要做什么事情。 Element抽象元素 接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。 ConcreteElement具体元素 实现accept方法，通常visitor.visit(this)，基本上都形成了一种模式了。 ObjectStruture结构对象 元素产生者，一般容纳在多个不同类、不同接口的容器，如List、Set、Map等。 访问者模式的优点 符合单一职责原则 优秀的扩展性 灵活性非常高 访问者模式的缺点 具体元素对访问者公布细节 具体元素变更比较困难 违背了依赖倒置原则 访问者模式的使用场景 一个对象结构包含很多对象，它们有不同的接口，而你想对这些对象实施一些依赖于具体类的操作。 需要对一个对象结构中的对象进行很多不同并且不相关的操作。 "},"patterns/state-pattern.html":{"url":"patterns/state-pattern.html","title":"状态模式","keywords":"","body":"状态模式（State Pattern） Allow an object to alter its behavior when its internal state changes. The object will appear to change its class. 当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。 State抽象状态角色 接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。 ConcreteState具体状态角色 每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态处理，通俗的说，就是本状态下要做的事情，以及本状态如何过渡到其他状态。 Context环境角色 定义客户端需要的接口，并且负责具体状态的切换。 状态模式的优点 结构清晰 避免了过多的switch...case或者if...else语句的使用，避免了程序的复杂性，提高了系统的可维护性。 遵循设计原则 很好地体现了开闭原则和单一职责原则，每个状态都是一个子类，需要添加状态时只需要增加子类，需要修改状态只需要修改子类。 封装性非常好 这也是状态模式的基本要求，状态变换放置到类的内部实现，外部的调用不需要知道类内部如何实现。 状态模式的缺点 只有一个缺点，那就是子类太多，状态过多，容易造成类膨胀。 状态模式的使用场景 行为随状态而改变的场景 条件、分支判断语句的替代者 "},"patterns/interpreter-pattern.html":{"url":"patterns/interpreter-pattern.html","title":"解释器模式","keywords":"","body":"解释器模式（Interpreter Pattern） Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences int the language. 给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。 AbstractExpression抽象解释器 TerminalExpression终结符表达式 实现与文法中元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。 NonterminalExpression非终结符表达式 文法中的每条规则对应于一个非终结符表达式。 Context环境角色 解释器模式的优点 解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只需要修改相应非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了。 解释器模式的缺点 解释器模式会引起类膨胀 解释器模式采用递归调用方法 效率问题 解释器模式的使用场景 重复发生的问题可以使用解释器模式 一个简单语法需要解释的场景 "},"patterns/flyweight-pattern.html":{"url":"patterns/flyweight-pattern.html","title":"享元模式","keywords":"","body":"享元模式（Flyweight Pattern） Use sharing to support large numbers of fine-grained objects efficiently. 使用共享对象可有效地支持大量细粒度的对象。 Flyweight抽象享元角色 简单的说，它是一个产品抽象类，同时定义了对象的外部状态和内部状态的接口或实现。 ConcreteFlyweight具体享元角色 具体的一个产品类，实现抽象角色定义的业务。该角色中需要注意的是内部状态处理应该与环境无关，不应该出现一个操作改变内部状态，同时修改了外部状态。 UnsharedConcreteFlyweight不可共享的享元角色 不存在外部状态或者安全要求（如线程安全）不能够使用共享技术的对象，该对象一般不会出现在享元工厂中。 FFlyweightFactory享元工厂 职责非常简单，就是构造一个容器，同时提供从池中获得对象的方法。 享元模式的优点 享元模式能大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能。 享元模式的缺点 需要分离外部状态和内部状态，提高了系统的复杂性，而且外部状态具有固化型，不能随内部状态改变而改变，否则导致系统的逻辑混乱。 享元模式的使用场景 系统中存在大量的相似对象。 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。 需要缓冲池的场景。 "},"patterns/bridge-pattern.html":{"url":"patterns/bridge-pattern.html","title":"桥梁模式","keywords":"","body":"桥梁模式（Bridge Pattern） 桥梁模式也叫做桥接模式。 Decouple an abstraction from its implementation so that the two can vary independently. 将抽象和实现解耦，使得两者可以独立地变化。 Abstraction抽象化角色 它的主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。 Implementor实现化角色 它是接口或者抽象类，定义角色必须的行为和属性。 RefinedAbstraction修正抽象化角色 它引用实现化角色对抽象化角色进行修正。 ConcreteImplementor具体实现化角色 它实现接口或抽象类定义的方法和属性。 桥梁模式的优点 抽象和实现分离 优秀的扩充能力 实现细节对客户透明 桥梁模式的使用场景 不希望或不适用使用继承的场景 接口或抽象类不稳定的场景 重用性要求较高的场景 "},"GLOSSARY.html":{"url":"GLOSSARY.html","title":"术语表","keywords":"","body":"术语 贫血对象 贫血对象（Thin Business Object）：一个对象不存储实体状态以及对象之间的关系，该对象叫做贫血对象，对应的领域叫做贫血领域模型。 充血模式 充血对象（Rich Business Object）：一个对象存储了实体状态以及对象关系，该对象叫做充血对象，对应的领域叫做充血领域模型。 "}}